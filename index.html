<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        h1 {
            margin-bottom: 2rem;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section {
            margin-bottom: 2rem;
        }

        .section h2 {
            margin-bottom: 1rem;
            font-size: 1.3rem;
            opacity: 0.9;
        }

        input {
            width: 100%;
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1rem;
            margin-bottom: 1rem;
            backdrop-filter: blur(5px);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            transition: all 0.3s ease;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        button:active {
            transform: translateY(-1px);
        }

        button:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            padding: 1rem;
            border-radius: 10px;
            margin: 1rem 0;
            font-weight: 500;
            transition: all 0.3s ease;
            white-space: pre-line;
            text-align: left;
            line-height: 1.4;
        }

        .status.connecting {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
        }

        .status.connected {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid rgba(40, 167, 69, 0.5);
        }

        .status.error {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid rgba(220, 53, 69, 0.5);
        }

        .controls {
            display: none;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .controls.show {
            display: flex;
        }

        .mute-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .mute-btn.muted {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .volume-slider {
            width: 100px;
        }

        .room-code {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 1rem 0;
            font-family: monospace;
            font-size: 1.2rem;
            font-weight: bold;
            letter-spacing: 2px;
            color: #fff;
        }

        .connection-data {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            margin: 1rem 0;
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
            max-height: 100px;
            overflow-y: auto;
        }

        .hidden {
            display: none;
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .tab {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .info {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 1rem;
            line-height: 1.4;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .connecting {
            animation: pulse 2s infinite;
        }

        @media (max-width: 480px) {
            .container {
                padding: 1.5rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
            
            .room-code {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ Voice Chat</h1>
        
        <div class="tabs">
            <button class="tab active" data-tab="create">Create Room</button>
            <button class="tab" data-tab="join">Join Room</button>
        </div>

        <div id="create-tab" class="tab-content active">
            <div class="section">
                <h2>üè† Create a Room</h2>
                <button id="testMicBtn">üîç Test Microphone First</button>
                <button id="createRoomBtn">Create Room & Enable Mic</button>
                <div id="roomCode" class="room-code hidden"></div>
                <div class="info">
                    Share the room code with your friend so they can join!
                </div>
            </div>
        </div>

        <div id="join-tab" class="tab-content">
            <div class="section">
                <h2>üö™ Join a Room</h2>
                <input type="text" id="joinRoomCode" placeholder="Enter room code (e.g. ABC123)">
                <button id="joinRoomBtn">Join Room & Enable Mic</button>
                <div class="info">
                    Enter the room code your friend shared with you.
                </div>
            </div>
        </div>

        <div id="status" class="status hidden"></div>

        <div id="connection-info" class="connection-data hidden"></div>

        <div id="controls" class="controls">
            <button id="muteBtn" class="mute-btn">üé§ Mute</button>
            <button id="hangupBtn">üìû Leave Room</button>
            <div class="volume-control">
                <span>üîä</span>
                <input type="range" id="volumeSlider" class="volume-slider" min="0" max="100" value="50">
            </div>
        </div>

        <div class="info">
            <p><strong>üîß Microphone Issues?</strong></p>
            <p>‚Ä¢ Make sure you're using <strong>HTTPS</strong> or <strong>localhost</strong></p>
            <p>‚Ä¢ Check browser address bar for üé§ icon and allow</p>
            <p>‚Ä¢ Try refreshing the page and allowing again</p>
            <p>‚Ä¢ Chrome: Go to Settings ‚Üí Privacy ‚Üí Site Settings ‚Üí Microphone</p>
            <br>
            <p><strong>How it works:</strong></p>
            <p>‚Ä¢ One person creates a room and shares the code</p>
            <p>‚Ä¢ The other person joins using that code</p>
            <p>‚Ä¢ Direct peer-to-peer connection (no servers!)</p>
        </div>
    </div>

    <audio id="remoteAudio" autoplay></audio>

    <script>
        class SimpleVoiceChat {
            constructor() {
                this.localStream = null;
                this.peerConnection = null;
                this.isInitiator = false;
                this.isMuted = false;
                this.roomCode = null;
                this.connectionEstablished = false;
                
                this.initElements();
                this.bindEvents();
            }

            initElements() {
                this.createRoomBtn = document.getElementById('createRoomBtn');
                this.joinRoomBtn = document.getElementById('joinRoomBtn');
                this.testMicBtn = document.getElementById('testMicBtn');
                this.testMicBtn2 = document.getElementById('testMicBtn2');
                this.roomCodeEl = document.getElementById('roomCode');
                this.joinRoomCodeEl = document.getElementById('joinRoomCode');
                this.statusEl = document.getElementById('status');
                this.connectionInfoEl = document.getElementById('connection-info');
                this.controlsEl = document.getElementById('controls');
                this.muteBtn = document.getElementById('muteBtn');
                this.hangupBtn = document.getElementById('hangupBtn');
                this.volumeSlider = document.getElementById('volumeSlider');
                this.remoteAudio = document.getElementById('remoteAudio');
                this.tabs = document.querySelectorAll('.tab');
                this.tabContents = document.querySelectorAll('.tab-content');
            }

            bindEvents() {
                // Add null checks for all elements
                if (this.createRoomBtn) this.createRoomBtn.addEventListener('click', () => this.createRoom());
                if (this.joinRoomBtn) this.joinRoomBtn.addEventListener('click', () => this.joinRoom());
                if (this.testMicBtn) this.testMicBtn.addEventListener('click', () => this.testMicrophone());
                if (this.testMicBtn2) this.testMicBtn2.addEventListener('click', () => this.testMicrophone());
                if (this.muteBtn) this.muteBtn.addEventListener('click', () => this.toggleMute());
                if (this.hangupBtn) this.hangupBtn.addEventListener('click', () => this.hangUp());
                if (this.volumeSlider) this.volumeSlider.addEventListener('input', () => this.adjustVolume());
                
                if (this.joinRoomCodeEl) {
                    this.joinRoomCodeEl.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') this.joinRoom();
                    });
                }

                this.tabs.forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });

                // Listen for connection data sharing via URL hash or localStorage
                this.setupConnectionSharing();

                // Run system diagnostics on load
                this.runDiagnostics();
            }

            switchTab(tabName) {
                this.tabs.forEach(tab => tab.classList.remove('active'));
                this.tabContents.forEach(content => content.classList.remove('active'));
                
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            }

            async runDiagnostics() {
                let diagnosticInfo = ['üîç System Diagnostics:'];
                
                // Check protocol
                diagnosticInfo.push(`üìç Protocol: ${window.location.protocol}`);
                if (window.location.protocol === 'file:') {
                    diagnosticInfo.push('‚ö†Ô∏è File protocol detected - microphone may not work');
                }
                
                // Check if we're in an iframe/sandbox
                if (window !== window.top) {
                    diagnosticInfo.push('‚ö†Ô∏è Running in iframe - may have restrictions');
                }
                
                // Check for required APIs
                if (!navigator.mediaDevices) {
                    diagnosticInfo.push('‚ùå MediaDevices API not available');
                } else {
                    diagnosticInfo.push('‚úÖ MediaDevices API available');
                }
                
                if (!window.RTCPeerConnection) {
                    diagnosticInfo.push('‚ùå WebRTC not available');
                } else {
                    diagnosticInfo.push('‚úÖ WebRTC available');
                }

                // Check permissions API
                if (navigator.permissions) {
                    try {
                        const micPermission = await navigator.permissions.query({ name: 'microphone' });
                        diagnosticInfo.push(`üé§ Mic permission: ${micPermission.state}`);
                    } catch (e) {
                        diagnosticInfo.push('üé§ Mic permission: unknown');
                    }
                } else {
                    diagnosticInfo.push('üé§ Permissions API not available');
                }

                // Check for secure context
                if (window.isSecureContext) {
                    diagnosticInfo.push('‚úÖ Secure context (HTTPS/localhost)');
                } else {
                    diagnosticInfo.push('‚ùå Not a secure context - microphone blocked');
                }

                console.log(diagnosticInfo.join('\n'));
            }

            async testMicrophone() {
                try {
                    this.showStatus('üß™ Testing microphone access...', 'connecting');
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        } 
                    });
                    
                    // Test successful - stop the stream
                    stream.getTracks().forEach(track => track.stop());
                    
                    this.showStatus('‚úÖ Microphone test successful! You can now create/join rooms.', 'connected');
                    
                } catch (error) {
                    console.error('Microphone test failed:', error);
                    
                    let errorDetails = [];
                    errorDetails.push('‚ùå Microphone Test Failed');
                    errorDetails.push(`Error: ${error.name} - ${error.message}`);
                    
                    // System-specific troubleshooting
                    if (error.message.includes('Permission denied by system')) {
                        errorDetails.push('');
                        errorDetails.push('üîß System-level fixes:');
                        errorDetails.push('‚Ä¢ Check OS microphone privacy settings');
                        errorDetails.push('‚Ä¢ Mac: System Preferences ‚Üí Security ‚Üí Microphone');
                        errorDetails.push('‚Ä¢ Windows: Settings ‚Üí Privacy ‚Üí Microphone');
                        errorDetails.push('‚Ä¢ Linux: Check pulseaudio/alsa permissions');
                        errorDetails.push('‚Ä¢ Restart browser after changing OS settings');
                    }
                    
                    if (!window.isSecureContext) {
                        errorDetails.push('');
                        errorDetails.push('üîí Security issue:');
                        errorDetails.push('‚Ä¢ Must use HTTPS or localhost');
                        errorDetails.push('‚Ä¢ file:// URLs are blocked');
                        errorDetails.push('‚Ä¢ Try: python -m http.server 8000');
                    }
                    
                    this.showStatus(errorDetails.join('\n'), 'error');
                }
            }

            async createRoom() {
                try {
                    await this.requestMicrophoneAccess();
                    
                    this.roomCode = this.generateRoomCode();
                    this.isInitiator = true;
                    
                    this.roomCodeEl.textContent = this.roomCode;
                    this.roomCodeEl.classList.remove('hidden');
                    
                    this.showStatus('Room created! Share this code with your friend.', 'connected');
                    
                    await this.initializePeerConnection();
                    this.waitForConnection();
                    
                } catch (error) {
                    console.error('Failed to create room:', error);
                    this.showStatus('Failed to create room: ' + error.message, 'error');
                }
            }

            async joinRoom() {
                const roomCode = this.joinRoomCodeEl.value.trim().toUpperCase();
                if (!roomCode) {
                    alert('Please enter a room code');
                    return;
                }

                try {
                    await this.requestMicrophoneAccess();
                    
                    this.roomCode = roomCode;
                    this.isInitiator = false;
                    
                    this.showStatus('Joining room...', 'connecting');
                    
                    await this.initializePeerConnection();
                    await this.joinExistingRoom();
                    
                } catch (error) {
                    console.error('Failed to join room:', error);
                    this.showStatus('Failed to join room: ' + error.message, 'error');
                }
            }

            generateRoomCode() {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            }

            async requestMicrophoneAccess() {
                if (this.localStream) return this.localStream;

                try {
                    this.showStatus('üé§ Attempting microphone access...', 'connecting');
                    
                    // Enhanced debugging
                    console.log('üîç Detailed microphone debugging:');
                    console.log('- Protocol:', window.location.protocol);
                    console.log('- Origin:', window.location.origin);
                    console.log('- Is secure context:', window.isSecureContext);
                    console.log('- User agent:', navigator.userAgent);
                    
                    // Check if we have permission first
                    if (navigator.permissions) {
                        const permission = await navigator.permissions.query({ name: 'microphone' });
                        console.log('- Permission state:', permission.state);
                        
                        if (permission.state === 'denied') {
                            throw new Error('Browser permission denied');
                        }
                    }

                    // List available devices first
                    try {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const audioInputs = devices.filter(device => device.kind === 'audioinput');
                        console.log('- Available audio inputs:', audioInputs.length);
                        audioInputs.forEach((device, i) => {
                            console.log(`  ${i}: ${device.label || 'Unknown Device'} (${device.deviceId.substring(0, 8)}...)`);
                        });
                        
                        if (audioInputs.length === 0) {
                            throw new Error('No microphone devices found');
                        }
                    } catch (deviceError) {
                        console.log('- Could not enumerate devices:', deviceError.message);
                    }

                    // Try multiple constraint configurations
                    const constraintOptions = [
                        // Most basic - should work on any system
                        { audio: true },
                        // With minimal processing
                        { 
                            audio: {
                                echoCancellation: false,
                                noiseSuppression: false,
                                autoGainControl: false
                            }
                        },
                        // With specific device if available
                        { 
                            audio: {
                                deviceId: 'default'
                            }
                        }
                    ];

                    for (let i = 0; i < constraintOptions.length; i++) {
                        try {
                            console.log(`- Trying constraint option ${i + 1}:`, constraintOptions[i]);
                            
                            this.localStream = await navigator.mediaDevices.getUserMedia(constraintOptions[i]);
                            
                            console.log('‚úÖ Microphone access granted with option', i + 1);
                            console.log('- Stream tracks:', this.localStream.getTracks().length);
                            this.localStream.getTracks().forEach(track => {
                                console.log(`  - ${track.kind}: ${track.label} (enabled: ${track.enabled})`);
                            });
                            
                            this.showStatus('‚úÖ Microphone ready!', 'connected');
                            return this.localStream;
                            
                        } catch (constraintError) {
                            console.log(`- Option ${i + 1} failed:`, constraintError.name, constraintError.message);
                            if (i === constraintOptions.length - 1) {
                                throw constraintError; // Re-throw the last error
                            }
                        }
                    }
                    
                } catch (error) {
                    console.error('‚ùå All microphone access attempts failed:', error);
                    
                    let errorMessage = ['‚ùå Microphone Access Failed'];
                    
                    if (error.name === 'NotAllowedError') {
                        if (error.message.includes('Permission denied by system')) {
                            errorMessage.push('');
                            errorMessage.push('üîß SYSTEM-LEVEL PERMISSION ISSUE:');
                            errorMessage.push('This means your operating system is blocking access.');
                            errorMessage.push('');
                            errorMessage.push('üíª Windows fixes:');
                            errorMessage.push('‚Ä¢ Windows Settings ‚Üí Privacy ‚Üí Microphone ‚Üí On');
                            errorMessage.push('‚Ä¢ Allow desktop apps to access microphone');
                            errorMessage.push('‚Ä¢ Check Windows Sound settings');
                            errorMessage.push('');
                            errorMessage.push('üçé Mac fixes:');
                            errorMessage.push('‚Ä¢ System Preferences ‚Üí Security & Privacy ‚Üí Microphone');
                            errorMessage.push('‚Ä¢ Enable for your browser');
                            errorMessage.push('‚Ä¢ Try: sudo tccutil reset Microphone');
                            errorMessage.push('');
                            errorMessage.push('üêß Linux fixes:');
                            errorMessage.push('‚Ä¢ Check: pavucontrol or alsamixer');
                            errorMessage.push('‚Ä¢ sudo usermod -a -G audio $USER');
                            errorMessage.push('‚Ä¢ Restart browser after changes');
                        } else {
                            errorMessage.push('Browser blocked microphone access');
                            errorMessage.push('‚Ä¢ Check address bar for üé§ icon');
                            errorMessage.push('‚Ä¢ Go to site settings and allow microphone');
                        }
                    } else if (error.name === 'NotFoundError') {
                        errorMessage.push('No microphone hardware detected');
                    } else if (error.name === 'NotReadableError') {
                        errorMessage.push('Microphone is being used by another app');
                    } else {
                        errorMessage.push(`Unknown error: ${error.message}`);
                    }
                    
                    errorMessage.push('');
                    errorMessage.push('üîÑ Try: Close browser completely and restart');
                    
                    this.showStatus(errorMessage.join('\n'), 'error');
                    throw error;
                }
            }

            async initializePeerConnection() {
                const config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                };

                this.peerConnection = new RTCPeerConnection(config);

                // Add local stream
                this.localStream.getTracks().forEach(track => {
                    this.peerConnection.addTrack(track, this.localStream);
                });

                // Handle remote stream
                this.peerConnection.ontrack = (event) => {
                    console.log('Received remote stream');
                    this.remoteAudio.srcObject = event.streams[0];
                    this.showStatus('üéâ Connected! You can now talk.', 'connected');
                    this.controlsEl.classList.add('show');
                    this.connectionEstablished = true;
                };

                // Handle ICE candidates
                this.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('New ICE candidate');
                        this.shareConnectionData({
                            type: 'ice-candidate',
                            candidate: event.candidate,
                            roomCode: this.roomCode
                        });
                    }
                };

                // Handle connection state changes
                this.peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', this.peerConnection.connectionState);
                    if (this.peerConnection.connectionState === 'connected') {
                        this.showStatus('üéâ Connected! You can now talk.', 'connected');
                    } else if (this.peerConnection.connectionState === 'disconnected') {
                        this.showStatus('Disconnected', 'error');
                        this.controlsEl.classList.remove('show');
                    } else if (this.peerConnection.connectionState === 'failed') {
                        this.showStatus('Connection failed. Please try again.', 'error');
                    }
                };
            }

            async waitForConnection() {
                this.showStatus('Waiting for someone to join...', 'connecting');
                // Connection will be established when someone calls joinExistingRoom
            }

            async joinExistingRoom() {
                // Create offer
                const offer = await this.peerConnection.createOffer();
                await this.peerConnection.setLocalDescription(offer);

                this.shareConnectionData({
                    type: 'offer',
                    sdp: offer,
                    roomCode: this.roomCode
                });

                this.showStatus('Connecting...', 'connecting');
            }

            shareConnectionData(data) {
                // For demo purposes, we'll display the connection data
                // In a real app, you'd send this via websockets, firebase, etc.
                const dataStr = JSON.stringify(data);
                console.log('Sharing connection data:', dataStr);
                
                // Store in localStorage with room code as key
                const key = `voice-chat-${this.roomCode}`;
                const existing = JSON.parse(localStorage.getItem(key) || '[]');
                existing.push(data);
                localStorage.setItem(key, JSON.stringify(existing));
                
                this.updateConnectionInfo(dataStr);
            }

            setupConnectionSharing() {
                // Poll for connection data
                setInterval(() => {
                    if (this.roomCode && !this.connectionEstablished) {
                        this.checkForConnectionData();
                    }
                }, 1000);
            }

            checkForConnectionData() {
                const key = `voice-chat-${this.roomCode}`;
                const data = JSON.parse(localStorage.getItem(key) || '[]');
                
                data.forEach(async (item) => {
                    if (item.type === 'offer' && !this.isInitiator) {
                        await this.handleOffer(item.sdp);
                    } else if (item.type === 'answer' && this.isInitiator) {
                        await this.handleAnswer(item.sdp);
                    } else if (item.type === 'ice-candidate') {
                        await this.handleIceCandidate(item.candidate);
                    }
                });
            }

            async handleOffer(offer) {
                if (this.peerConnection.remoteDescription) return;
                
                await this.peerConnection.setRemoteDescription(offer);
                const answer = await this.peerConnection.createAnswer();
                await this.peerConnection.setLocalDescription(answer);

                this.shareConnectionData({
                    type: 'answer',
                    sdp: answer,
                    roomCode: this.roomCode
                });
            }

            async handleAnswer(answer) {
                if (this.peerConnection.remoteDescription) return;
                await this.peerConnection.setRemoteDescription(answer);
            }

            async handleIceCandidate(candidate) {
                try {
                    await this.peerConnection.addIceCandidate(candidate);
                } catch (error) {
                    console.error('Error adding ICE candidate:', error);
                }
            }

            toggleMute() {
                if (!this.localStream) return;

                this.isMuted = !this.isMuted;
                this.localStream.getAudioTracks().forEach(track => {
                    track.enabled = !this.isMuted;
                });

                this.muteBtn.textContent = this.isMuted ? 'üîá Unmute' : 'üé§ Mute';
                this.muteBtn.classList.toggle('muted', this.isMuted);
            }

            adjustVolume() {
                const volume = this.volumeSlider.value / 100;
                this.remoteAudio.volume = volume;
            }

            hangUp() {
                if (this.peerConnection) {
                    this.peerConnection.close();
                }
                
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }

                // Clear connection data
                if (this.roomCode) {
                    localStorage.removeItem(`voice-chat-${this.roomCode}`);
                }

                this.controlsEl.classList.remove('show');
                this.roomCodeEl.classList.add('hidden');
                this.connectionInfoEl.classList.add('hidden');
                this.showStatus('Disconnected', 'error');
                this.connectionEstablished = false;
                
                // Reset form
                this.joinRoomCodeEl.value = '';
            }

            updateConnectionInfo(data) {
                this.connectionInfoEl.textContent = `Latest: ${data.substring(0, 100)}...`;
                this.connectionInfoEl.classList.remove('hidden');
            }

            showStatus(message, type) {
                this.statusEl.textContent = message;
                this.statusEl.className = `status ${type}`;
                this.statusEl.classList.remove('hidden');
            }
        }

        // Initialize the voice chat when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SimpleVoiceChat();
        });
    </script>
</body>
</html>
